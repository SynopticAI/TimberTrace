<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TimberTrace Visualizer</title>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        
        #container { display: flex; height: 100vh; }
        #sidebar { width: 350px; background: #2c3e50; color: #ecf0f1; padding: 20px; overflow-y: auto; }
        #viewer { flex: 1; position: relative; background: #34495e; }
        
        h1 { font-size: 20px; margin-bottom: 20px; color: #3498db; }
        h2 { font-size: 16px; margin-top: 20px; margin-bottom: 10px; color: #ecf0f1; }
        
        .tabs { display: flex; gap: 5px; margin-bottom: 20px; }
        .tab { flex: 1; padding: 10px; background: #34495e; border: none; color: #ecf0f1; 
               cursor: pointer; border-radius: 5px; font-size: 13px; transition: 0.2s; }
        .tab:hover { background: #3498db; }
        .tab.active { background: #3498db; font-weight: bold; }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        label { display: block; margin-top: 15px; margin-bottom: 5px; font-size: 13px; color: #bdc3c7; }
        select, button { width: 100%; padding: 10px; font-size: 13px; border-radius: 5px; 
                        border: 1px solid #34495e; background: #34495e; color: #ecf0f1; }
        select:focus, button:focus { outline: none; border-color: #3498db; }
        
        button { background: #27ae60; cursor: pointer; margin-top: 10px; font-weight: bold; 
                transition: 0.2s; }
        button:hover { background: #2ecc71; }
        button:active { transform: scale(0.98); }
        
        .info { margin-top: 15px; padding: 10px; background: #34495e; border-radius: 5px; 
               font-size: 12px; color: #95a5a6; }
        .error { background: #e74c3c; color: white; padding: 10px; border-radius: 5px; 
                margin-top: 10px; font-size: 12px; }
        
        #status { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); 
                 color: white; padding: 10px 15px; border-radius: 5px; font-size: 12px; }
        
        .constraint-info { background: #34495e; padding: 8px; border-radius: 5px; 
                          margin-top: 8px; font-size: 11px; }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>ðŸªµ TimberTrace Visualizer</h1>
            
            <div class="tabs">
                <button class="tab active" onclick="switchTab('scene')">Scene Viewer</button>
                <button class="tab" onclick="switchTab('beam')">Beam Tester</button>
                <button class="tab" onclick="switchTab('connection')">Connection</button>
            </div>
            
            <!-- SCENE VIEWER TAB -->
            <div id="tab-scene" class="tab-content active">
                <h2>Scene Viewer</h2>
                <label>Select Scene</label>
                <select id="sceneSelect" onchange="loadScene()">
                    <option value="">-- Select Scene --</option>
                </select>
                <div id="sceneInfo" class="info"></div>
            </div>
            
            <!-- BEAM TESTER TAB -->
            <div id="tab-beam" class="tab-content">
                <h2>Beam Tester</h2>
                <label>Beam Type</label>
                <select id="beamTypeSelect" onchange="updateBeamInfo()">
                    <option value="0">Pfosten (Post)</option>
                    <option value="1">Pfette (Purlin)</option>
                </select>
                
                <button onclick="generateBeam()">Generate Beam</button>
                
                <div id="beamInfo"></div>
                
                <label>Constraint Face</label>
                <select id="constraintFaceSelect" onchange="updateConstraintList()">
                    <option value="">-- Select Face --</option>
                </select>
                
                <label>Constraint Point/Line/Plane</label>
                <select id="constraintIndexSelect">
                    <option value="">-- Select Constraint --</option>
                </select>
                
                <button onclick="visualizeConstraint()">Show Constraint</button>
            </div>
            
            <!-- CONNECTION CHECKER TAB -->
            <div id="tab-connection" class="tab-content">
                <h2>Connection Checker</h2>
                
                <label>Beam A Type</label>
                <select id="beamAType" onchange="updateConnectionInfo()">
                    <option value="0">Pfosten (Post)</option>
                    <option value="1">Pfette (Purlin)</option>
                </select>
                
                <label>Beam B Type</label>
                <select id="beamBType" onchange="updateConnectionInfo()">
                    <option value="0">Pfosten (Post)</option>
                    <option value="1">Pfette (Purlin)</option>
                </select>
                
                <label>Face A</label>
                <select id="faceASelect" onchange="updateConnectionConstraints()">
                    <option value="4">Top</option>
                    <option value="5">Bottom</option>
                    <option value="0">Right</option>
                    <option value="1">Left</option>
                    <option value="2">Front</option>
                    <option value="3">Back</option>
                </select>
                
                <label>Face B (Opposite Auto)</label>
                <select id="faceBSelect" disabled>
                    <option value="5">Bottom</option>
                </select>
                
                <label>Constraint Index A</label>
                <select id="constraintAIndex">
                    <option value="0">0</option>
                </select>
                
                <label>Constraint Index B</label>
                <select id="constraintBIndex">
                    <option value="0">0</option>
                </select>
                
                <button onclick="checkConnection()">Generate & Solve</button>
                
                <div id="connectionInfo" class="info"></div>
            </div>
        </div>
        
        <div id="viewer">
            <div id="status">Ready</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // === THREE.JS SETUP ===
        let scene, camera, renderer, controls;
        let beamMeshes = [];
        let constraintVisuals = [];
        let currentBeamInfo = {};
        
        const FACE_NAMES = ['right', 'left', 'front', 'back', 'top', 'bottom'];
        const OPPOSITE_FACES = {0: 1, 1: 0, 2: 3, 3: 2, 4: 5, 5: 4};
        
        function initThreeJS() {
            const container = document.getElementById('viewer');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            
            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
            scene.add(gridHelper);
            
            // Axes
            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);
            
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            const container = document.getElementById('viewer');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // === UTILITY FUNCTIONS ===
        function clearScene() {
            beamMeshes.forEach(mesh => scene.remove(mesh));
            constraintVisuals.forEach(obj => scene.remove(obj));
            beamMeshes = [];
            constraintVisuals = [];
        }
        
        function createBeamMesh(beamData) {
            const [w, d, h] = beamData.dimensions;
            // Three.js: Y is vertical (up), so map height to Y
            const geometry = new THREE.BoxGeometry(w, h, d);  // width, HEIGHT, depth
            const material = new THREE.MeshStandardMaterial({ 
                color: beamData.type === 'Pfosten' ? 0x8B4513 : 0xD2691E,
                metalness: 0.3,
                roughness: 0.7
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set(beamData.position[0], beamData.position[2], beamData.position[1]);
            mesh.rotation.set(0, beamData.rotation[2], 0);
            
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
            mesh.add(line);
            
            return mesh;
        }
        
        function setStatus(text, isError = false) {
            const status = document.getElementById('status');
            status.textContent = text;
            status.style.background = isError ? 'rgba(231, 76, 60, 0.9)' : 'rgba(0, 0, 0, 0.7)';
        }
        
        // === TAB SWITCHING ===
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById('tab-' + tabName).classList.add('active');
            
            clearScene();
            setStatus('Tab: ' + tabName);
        }
        
        // === SCENE VIEWER ===
        async function loadSceneList() {
            console.log('Loading scene list...');
            const response = await fetch('/api/scenes');
            const data = await response.json();
            console.log('Scene data:', data);
            
            const select = document.getElementById('sceneSelect');
            select.innerHTML = '<option value="">-- Select Scene --</option>';
            
            if (data.error) {
                console.error('Error loading scenes:', data.error);
                setStatus(data.error, true);
                return;
            }
            
            data.scenes.forEach(scene => {
                const option = document.createElement('option');
                option.value = scene;
                option.textContent = scene;
                select.appendChild(option);
            });
            
            console.log(`Loaded ${data.scenes.length} scenes`);
        }
        
        async function loadScene() {
            const sceneId = document.getElementById('sceneSelect').value;
            if (!sceneId) return;
            
            console.log('Loading scene:', sceneId);
            setStatus('Loading scene...');
            clearScene();
            
            const response = await fetch(`/api/scene/${sceneId}`);
            const data = await response.json();
            console.log('Scene data:', data);
            
            if (data.error) {
                console.error('Error loading scene:', data.error);
                setStatus(data.error, true);
                return;
            }
            
            data.beams.forEach(beam => {
                console.log('Creating beam:', beam);
                const mesh = createBeamMesh(beam);
                scene.add(mesh);
                beamMeshes.push(mesh);
            });
            
            document.getElementById('sceneInfo').innerHTML = `
                <strong>Scene ${data.scene_id}</strong><br>
                Beams: ${data.num_beams}
            `;
            
            setStatus(`Loaded ${data.num_beams} beams`);
        }
        
        // === BEAM TESTER ===
        async function updateBeamInfo() {
            const beamType = document.getElementById('beamTypeSelect').value;
            const response = await fetch(`/api/beam_info/${beamType}`);
            const data = await response.json();
            
            currentBeamInfo = data;
            
            let infoHTML = `<div class="constraint-info"><strong>${data.beam_type}</strong><br>`;
            
            const faceSelect = document.getElementById('constraintFaceSelect');
            faceSelect.innerHTML = '<option value="">-- Select Face --</option>';
            
            FACE_NAMES.forEach((name, idx) => {
                const info = data.constraints[name];
                if (info.available) {
                    infoHTML += `${name}: ${info.count} constraints<br>`;
                    const option = document.createElement('option');
                    option.value = idx;
                    option.textContent = `${name} (${info.count} constraints)`;
                    faceSelect.appendChild(option);
                }
            });
            
            infoHTML += '</div>';
            document.getElementById('beamInfo').innerHTML = infoHTML;
        }
        
        function updateConstraintList() {
            const beamType = document.getElementById('beamTypeSelect').value;
            const faceIdx = parseInt(document.getElementById('constraintFaceSelect').value);
            
            if (isNaN(faceIdx) || !currentBeamInfo.constraints) return;
            
            const faceName = FACE_NAMES[faceIdx];
            const constraints = currentBeamInfo.constraints[faceName].constraints;
            
            const select = document.getElementById('constraintIndexSelect');
            select.innerHTML = '';
            
            constraints.forEach(c => {
                const option = document.createElement('option');
                option.value = c.index;
                option.textContent = `Index ${c.index} (${c.type})`;
                select.appendChild(option);
            });
        }
        
        async function generateBeam() {
            const beamType = document.getElementById('beamTypeSelect').value;
            
            console.log('Generating beam type:', beamType);
            setStatus('Generating beam...');
            clearScene();
            
            const response = await fetch('/api/generate_beam', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ beam_type: parseInt(beamType) })
            });
            
            const data = await response.json();
            console.log('Generated beam data:', data);
            
            const mesh = createBeamMesh(data);
            scene.add(mesh);
            beamMeshes.push(mesh);
            
            setStatus('Beam generated');
            console.log('Beam added to scene');
        }
        
        async function visualizeConstraint() {
            const beamType = document.getElementById('beamTypeSelect').value;
            const face = document.getElementById('constraintFaceSelect').value;
            const constraintIdx = document.getElementById('constraintIndexSelect').value;
            
            if (!face || constraintIdx === '') {
                setStatus('Select face and constraint', true);
                return;
            }
            
            setStatus('Visualizing constraint...');
            
            // Clear old constraint visuals
            constraintVisuals.forEach(obj => scene.remove(obj));
            constraintVisuals = [];
            
            const response = await fetch('/api/visualize_constraint', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    beam_type: parseInt(beamType),
                    face: parseInt(face),
                    constraint_index: parseInt(constraintIdx)
                })
            });
            
            const data = await response.json();
            
            if (data.type === 'point') {
                const geometry = new THREE.SphereGeometry(0.05, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const sphere = new THREE.Mesh(geometry, material);
                const [x, y, z] = data.points[0];
                sphere.position.set(x, z, y);
                scene.add(sphere);
                constraintVisuals.push(sphere);
            } else if (data.type === 'line') {
                const points = data.points.map(p => new THREE.Vector3(p[0], p[2], p[1]));
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                constraintVisuals.push(line);
            } else if (data.type === 'plane') {
                data.points.forEach(p => {
                    const geometry = new THREE.SphereGeometry(0.02, 8, 8);
                    const material = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.6 });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(p[0], p[2], p[1]);
                    scene.add(sphere);
                    constraintVisuals.push(sphere);
                });
            }
            
            setStatus(`Constraint: ${data.type}`);
        }
        
        // === CONNECTION CHECKER ===
        function updateConnectionInfo() {
            const faceA = parseInt(document.getElementById('faceASelect').value);
            const faceB = OPPOSITE_FACES[faceA];
            
            const faceBSelect = document.getElementById('faceBSelect');
            faceBSelect.value = faceB;
            faceBSelect.innerHTML = `<option value="${faceB}">${FACE_NAMES[faceB]}</option>`;
        }
        
        async function updateConnectionConstraints() {
            // Update available constraint indices based on beam types and faces
            updateConnectionInfo();
        }
        
        async function checkConnection() {
            const beamAType = parseInt(document.getElementById('beamAType').value);
            const beamBType = parseInt(document.getElementById('beamBType').value);
            const faceA = parseInt(document.getElementById('faceASelect').value);
            const faceB = OPPOSITE_FACES[faceA];
            const constraintAIdx = parseInt(document.getElementById('constraintAIndex').value);
            const constraintBIdx = parseInt(document.getElementById('constraintBIndex').value);
            
            setStatus('Solving connection...');
            clearScene();
            
            const response = await fetch('/api/check_connection', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    beam_a_type: beamAType,
                    beam_b_type: beamBType,
                    face_a: faceA,
                    face_b: faceB,
                    constraint_idx_a: constraintAIdx,
                    constraint_idx_b: constraintBIdx
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                data.beams.forEach(beam => {
                    const mesh = createBeamMesh(beam);
                    scene.add(mesh);
                    beamMeshes.push(mesh);
                });
                
                // Show connection points
                const pointA = data.connection_points.beam_a;
                const pointB = data.connection_points.beam_b;
                
                [pointA, pointB].forEach((p, i) => {
                    const geometry = new THREE.SphereGeometry(0.08, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ color: i === 0 ? 0xff0000 : 0x00ff00 });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(p[0], p[2], p[1]);
                    scene.add(sphere);
                    constraintVisuals.push(sphere);
                });
                
                // Draw line between connection points
                const points = [
                    new THREE.Vector3(pointA[0], pointA[2], pointA[1]),
                    new THREE.Vector3(pointB[0], pointB[2], pointB[1])
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 3 });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                constraintVisuals.push(line);
                
                const distance = Math.sqrt(
                    Math.pow(pointA[0] - pointB[0], 2) +
                    Math.pow(pointA[1] - pointB[1], 2) +
                    Math.pow(pointA[2] - pointB[2], 2)
                );
                
                document.getElementById('connectionInfo').innerHTML = `
                    <strong>Connection Solved</strong><br>
                    Distance: ${(distance * 1000).toFixed(2)}mm<br>
                    ${distance < 0.001 ? 'âœ“ Perfect contact' : 'âš  Gap detected'}
                `;
                
                setStatus('Connection solved');
            } else {
                setStatus('Solver failed: ' + data.error, true);
            }
        }
        
        // === INITIALIZATION ===
        window.onload = () => {
            initThreeJS();
            loadSceneList();
            updateBeamInfo();
            updateConnectionInfo();
        };
        
        // === EXPOSE FUNCTIONS TO WINDOW FOR ONCLICK HANDLERS ===
        window.switchTab = switchTab;
        window.loadScene = loadScene;
        window.generateBeam = generateBeam;
        window.updateBeamInfo = updateBeamInfo;
        window.updateConstraintList = updateConstraintList;
        window.visualizeConstraint = visualizeConstraint;
        window.updateConnectionInfo = updateConnectionInfo;
        window.updateConnectionConstraints = updateConnectionConstraints;
        window.checkConnection = checkConnection;
    </script>
</body>
</html>